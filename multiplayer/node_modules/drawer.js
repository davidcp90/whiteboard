var Task = require('dataflo.ws/task/base');
var Canvas = require('canvas');
var util = require('util');

var Figure = require('../htdocs/src/figure').Figure;
var SharedDrawer = require('../htdocs/src/drawer').Drawer;

var Drawer = module.exports = function (config) {
	this.init(config);
};

util.inherits(Drawer, Task);

util.extend(Drawer.prototype, SharedDrawer.prototype);

util.extend(Drawer.prototype, {
	/**
	 * @private
	 */
	canvases: {},

	/**
	 * @private
	 */
	getOrCreateCanvas: function (id, w, h) {
		this.canvas = this.canvases[id];

		if (id in this.canvases) {
			this.canvas = this.canvases[id];
			this.width = this.canvas.width;
			this.height = this.canvas.height;
			this.context = this.canvas.getContext('2d');
			this.resize(w, h);
		} else {
			this.canvas = this.canvases[id] = new Canvas(w, h);
			this.context = this.canvas.getContext('2d');
			this.width = w;
			this.height = h;
		}
	},

	/**
	 * @private
	 */
	getData: function () {
		return this.canvas.toBuffer();
	},

	/**
	 * @private
	 */
	putData: function (data, x, y) {
		var img = new Canvas.Image;
		img.src = data;
		this.context.drawImage(
			img, x || 0, y || 0, img.width, img.height
		);
	},

	/**
	 * Draw an array of pixels on a given canvas.
	 *
	 * @param {String} config.canvasId (required) The ID of the canvas
	 * @param {Number} config.width Width of canvas
	 * @param {Number} config.height Height of canvas
	 * @param {Array} config.figure (required) An array of dots to draw
	 * @param {Number} config.figure.radius (required) The size of brush
	 * @param {String} config.figure.color (required) The color of brush
	 */
	run: function () {
		this.getOrCreateCanvas(
			this.data.wbId, this.data.width, this.data.height
		);
		this.drawFigure(this.data.figure);
		this.completed(this.canvas);
	},

	/**
	 * Restores from PNG.
	 */
	drawPng: function () {
		var png = this.pngBuffer;
		var img = new Canvas.Image;
		img.src = png;

		this.getOrCreateCanvas(this.canvasId, img.width, img.height);

		try {
			this.drawUnder(img);
			this.completed(true);
		} catch (e) {
			this.failed(e);
		}
	},

	/**
	 * Export a canvas to binary image.
	 *
	 * @param {String} config.canvasId (required) The ID of a canvas instance
	 */
	exportToPng: function () {
		var canvas = this.canvases[this.canvasId];

		if (canvas) {
			var my = this;
			canvas.toBuffer(function (err, buf) {
				my.completed({
					ok: !!err,
					err: err,
					buffer: buf
				});
			});
		} else {
			this.completed({
				ok: false,
				err: 'No canvas'
			});
		}
	},

	/**
	 * Delete unused canvases.
	 *
	 * @param {String} config.canvasId The ID of a canvas instance
	 */
	clear: function () {
		var canvases = this.canvases;

		if (this.canvasId) {
			delete canvases[this.canvasId];
			console.log('Deleted canvas with ID %s', this.canvasId);
		} else {
			Object.keys(canvases).forEach(function (key) {
				delete canvases[key];
			});
			console.log('Deleted all canvases');
		}

		this.completed({
			ok: true,
			msg: 'Deleted'
		});
	}
});
